type MaybeIndex : 0..9;
type StrictIndex : 1..9;
type NextIndex : 1..10;

type MaybeTerm : 0..9;
type StrictTerm : 1..9;

type ServerId : 1..5;

type Entry : record {
  term: StrictTerm,
  // value omitted
};

type Log : Vector<Entry>[StrictIndex];

type CandidatePeer : record {
  voteResponded: Boolean,
  voteGranted: Boolean,
  requestVoteAt: Time,
};

type LeaderPeer : record {
  nextIndex: NextIndex,
  matchIndex: MaybeIndex,
  appendEntriesAt: Time,
};

type Server : record {
  timeoutAt: Time,
  currentTerm: StrictTerm,
  state: either {
    Follower {
      vote: either {
        Available,
        Granted { to: ServerId },
      },
    },
    Candidate {
      peers: Array<CandidatePeer>[ServerId],
    },
    Leader {
      peers: Array<LeaderPeer>[ServerId],
    },
  },
  log: Log,
  commitIndex: MaybeIndex,
};

var servers: Array<Server>[ServerId];

type Message : record {
  from: ServerId,
  to: ServerId,
  sentAt: Time,
  deliverAt: Time,
  payload: either {
    RequestVoteRequest {
      term: StrictTerm,
      lastLogTerm: MaybeTerm,
      lastLogIndex: MaybeIndex,
    },
    RequestVoteResponse {
      term: StrictTerm,
      granted: Boolean,
    },
    AppendEntriesRequest {
      term: StrictTerm,
      prevLogIndex: MaybeIndex,
      prevLogTerm: MaybeTerm,
      entries: Log,
      commitIndex: MaybeIndex,
    },
    AppendEntriesResponse {
      term: StrictTerm,
      success: Boolean,
      matchIndex: MaybeIndex,
    },
  },
};

var network : MultiSet<Message>[0..20];

////////// History Variables //////////

// Used to check election safety property.
type ElectionResult : either {
  NoWinner,
  Winner { won: ServerId }
};
var electionHistory : Array<ElectionResult>[StrictTerm];

// Used to check leader completeness property
type CommittedEntry : record {
  entry: Entry,
  termCommitted: StrictTerm,
};
var committedEntries : Vector<CommittedEntry>[StrictIndex];

function makeElectionTimeout() -> Time {
  return later(urandomRange(100000, 200000));
}

function lastTerm(log: Log) -> MaybeTerm {
  if empty(log) {
    return 0;
  } else {
    return log[size(log)].term;
  }
}

function quorum(serverSet: Set<ServerId>[ServerId]) -> Boolean {
  return size(serverSet) * 2 > size(servers);
}

function sendMessage(message: Message) {
  message.sentAt = later(0);
  message.deliverAt = later(urandomRange(10000, 20000));
  push(network, message);
}

// initialization
for server in servers {
  server.timeoutAt = makeElectionTimeout();
}

/*
rule startOver {
  for server in servers {
    if server.currentTerm == 9 || full(server.log) {
      reset;
    }
  }
}
*/

external restart for serverId, server in servers {
  // just meant to remember the term, log, and vote
  match server.state {
    Follower => { /* retain existing vote */ },
    Candidate => {
      server.state = Follower {
        vote: Granted { to: serverId },
      };
    },
    Leader => {
      server.state = Follower {
        vote: Granted { to: serverId },
      };
    },
  }
  server.commitIndex = 0;
  server.timeoutAt = makeElectionTimeout();
}

rule timeout for serverId, server in servers {
  var doTimeout : Boolean;
  match server.state {
    Follower  => { doTimeout = True; },
    Candidate => { doTimeout = True; },
    Leader    => { doTimeout = False; }
  }
  if (past(server.timeoutAt) &&
      doTimeout &&
      server.currentTerm < 9 /* max term */) {
    server.currentTerm += 1;
    var peers: Array<CandidatePeer>[ServerId];
    peers[serverId] = CandidatePeer {
      voteResponded: True,
      voteGranted: True,
    };
    server.state = Candidate { peers: peers };
    server.timeoutAt = makeElectionTimeout();
  }
}

rule sendRequestVote for serverId, server in servers {
  if !full(network) {
    match server.state {
      Follower => { /* do nothing */ },
      Candidate as cstate => {
        var notResponded : Set<ServerId>[ServerId];
        for peerId, peer in cstate.peers {
          if !peer.voteResponded {
            push(notResponded, peerId);
          }
        }
        if !empty(notResponded) {
          var target : ServerId =
            notResponded[urandomRange(1, size(notResponded))];
          if past(cstate.peers[target].requestVoteAt) {
            sendMessage(Message {
              from: serverId,
              to: target,
              payload: RequestVoteRequest {
                term: server.currentTerm,
                lastLogTerm: lastTerm(server.log),
                lastLogIndex: size(server.log),
              },
            });
            cstate.peers[target].requestVoteAt = later(50000);
            server.state = cstate;
          }
        }
      },
      Leader => { /* do nothing */ }
    }
  }
}

rule becomeLeader for serverId, server in servers {
  match server.state {
    Follower => { /* do nothing */ },
    Candidate as cstate => {
      var granted : Set<ServerId>[ServerId];
      for peerId, peer in cstate.peers {
        if peer.voteGranted {
          push(granted, peerId);
        }
      }
      if quorum(granted) {
        var peers : Array<LeaderPeer>[ServerId];
        peers[serverId].matchIndex = size(server.log);
        peers[serverId].nextIndex = size(server.log) + 1;
        server.state = Leader {
          peers: peers,
        };
        assert electionHistory[server.currentTerm] == NoWinner;
        electionHistory[server.currentTerm] = Winner { won: serverId };
      }
    },
    Leader => { /* do nothing */ }
  }
}

rule sendAppendEntries for serverId, server in servers {
  if !full(network) && size(servers) > 1 {
    match server.state {
      Follower => { /* do nothing */ },
      Candidate => { /* do nothing */ },
      Leader as lstate => {
        var peerId : ServerId = serverId;
        while peerId == serverId {
          peerId = urandom<ServerId>();
        }
        if past(lstate.peers[peerId].appendEntriesAt) {
          var prevLogIndex : MaybeIndex = lstate.peers[peerId].nextIndex - 1;
          var prevLogTerm : MaybeTerm = 0;
          if prevLogIndex > 0 {
            prevLogTerm = server.log[prevLogIndex].term;
          }
          var entries : Log;
          var index : NextIndex = prevLogIndex + 1;
          var limit : MaybeIndex = 1;
          while index <= size(server.log) && limit > 0 {
            push(entries, server.log[index]);
            index += 1;
            limit -= 1;
          }
          var commitIndex : MaybeIndex = server.commitIndex;
          if server.commitIndex > index {
            commitIndex = index;
          }
          sendMessage(Message {
            from: serverId,
            to: peerId,
            payload: AppendEntriesRequest {
              term: server.currentTerm,
              prevLogIndex: prevLogIndex,
              prevLogTerm: prevLogTerm,
              entries: entries,
              commitIndex: commitIndex,
            },
          });
          lstate.peers[peerId].appendEntriesAt = later(50000);
          server.state = lstate;
        }
      }
    }
  }
}

external clientRequest for serverId, server in servers {
  if !full(server.log) {
    match server.state {
      Follower => { /* redirect client */},
      Candidate => { /* redirect client */ },
      Leader as lstate => {
        push(server.log, Entry {
          term: server.currentTerm,
          // value: to client-provided command
        });
        for peerId, peer in lstate.peers {
          if peerId == serverId {
            peer.nextIndex += 1;
            peer.matchIndex += 1;
          } else {
            peer.appendEntriesAt = 0;
          }
        }
        server.state = lstate;
      }
    }
  }
}

rule advanceCommitIndex for serverId, server in servers {
  match server.state {
    Follower => { /* do nothing */},
    Candidate => { /* do nothing */ },
    Leader as lstate => {
      var quorumMatchIndex : MaybeIndex = 0;
      for peerId, peer in lstate.peers {
        // The set of servers with match index >= peer.matchIndex.
        var geq : Set<ServerId>[ServerId];
        for p2Id, p2 in lstate.peers {
          if p2.matchIndex >= peer.matchIndex {
            push(geq, p2Id);
          }
        }
        if quorum(geq) && peer.matchIndex > quorumMatchIndex {
          quorumMatchIndex = peer.matchIndex;
        }
      }
      if (quorumMatchIndex > 0 &&
          server.log[quorumMatchIndex].term == server.currentTerm) {
        // save new commit index
        server.commitIndex = quorumMatchIndex;

        // update committedEntries history variable
        for index, entry in server.log {
          if index > server.commitIndex {
            break;
          }
          if index == size(committedEntries) + 1 {
            push(committedEntries, CommittedEntry {
              entry: entry,
              termCommitted: server.currentTerm,
            });
          } else {
            assert committedEntries[index].entry == entry;
            if committedEntries[index].termCommitted > server.currentTerm {
              committedEntries[index].termCommitted = server.currentTerm;
            }
          }
        }
      }
    } // Leader
  } // match
}

rule handleMessage for message in network {
  if past(message.deliverAt) {
    var from : ServerId = message.from;
    var to : ServerId = message.to;
    match message.payload {
      RequestVoteRequest as request => {
        if request.term > servers[to].currentTerm {
          servers[to].currentTerm = request.term;
          servers[to].state = Follower {};
          // leave request in network for further processing
        } else {
          // check that vote is available and if so, record vote
          var granted : Boolean = False;
          if (request.term == servers[to].currentTerm &&
              (request.lastLogTerm > lastTerm(servers[to].log) ||
               (request.lastLogTerm == lastTerm(servers[to].log) &&
                request.lastLogIndex >= size(servers[to].log)))) {
            match servers[to].state {
              Follower as fstate => {
                match fstate.vote {
                  Available => {
                    granted = True;
                    fstate.vote = Granted { to: from };
                    servers[to].state = fstate;
                  },
                  Granted as g => {
                    granted = (g.to == from);
                  },
                }
              },
              Candidate => { granted = (from == to); },
              Leader    => { granted = (from == to); },
            }
          }
          if granted {
            servers[to].timeoutAt = makeElectionTimeout();
          }
          remove(network, message);
          sendMessage(Message {
            from: to,
            to: from,
            payload: RequestVoteResponse {
              term: servers[to].currentTerm,
              granted: granted,
            },
          });
        }
      }, // RequestVoteRequest

      RequestVoteResponse as reply => {
        if reply.term == servers[to].currentTerm {
          match servers[to].state {
            Follower => {
              // Must have restarted to get back into Follower state after
              // requesting votes. Just ignore it.
            },
            Candidate as cstate => {
              cstate.peers[from].voteResponded = True;
              cstate.peers[from].voteGranted = reply.granted;
              servers[to].state = cstate;
            },
            Leader => { /* ignore */ },
          }
        } else {
          if reply.term > servers[to].currentTerm {
            servers[to].currentTerm = reply.term;
            servers[to].state = Follower {};
          } else {
            // stale term: ignore
          }
        }
        remove(network, message);
      }, // RequestVoteResponse

      AppendEntriesRequest as request => {
        if request.term > servers[to].currentTerm {
          servers[to].currentTerm = request.term;
          servers[to].state = Follower {};
          // leave request in network for further processing
        } else {
          var rejectReply : Message = Message {
            from: to,
            to: from,
            payload: AppendEntriesResponse {
              term: servers[to].currentTerm,
              success: False,
              matchIndex: 0,
            },
          };
          if request.term < servers[to].currentTerm {
            remove(network, message);
            sendMessage(rejectReply);
          } else { // request.term == servers[to].currentTerm
            servers[to].timeoutAt = makeElectionTimeout();
            match servers[to].state {
              Follower => {
                var logOk : Boolean = (
                  request.prevLogIndex == 0 ||
                    (request.prevLogIndex <= size(servers[to].log) &&
                     request.prevLogTerm ==
                      servers[to].log[request.prevLogIndex].term));
                if logOk {
                  var done : Boolean = True;
                  var index : MaybeIndex = request.prevLogIndex;
                  for entry in request.entries {
                    index += 1;
                    if index <= size(servers[to].log) {
                      if servers[to].log[index].term == entry.term {
                        // already have this entry
                        continue;
                      } else {
                        // terms conflict at 'index': remove last entry in
                        // server's log
                        var lastIndex : StrictIndex = size(servers[to].log);
                        remove(servers[to].log, servers[to].log[lastIndex]);
                        // leave request in network for further processing
                        done = False;
                        break;
                      }
                    } else { // new entry
                      push(servers[to].log, entry);
                      assert index == size(servers[to].log);
                      // leave request in network for further processing
                      done = False;
                      break;
                    }
                  }
                  if done {
                    servers[to].commitIndex = request.commitIndex;
                    remove(network, message);
                    sendMessage(Message {
                      from: to,
                      to: from,
                      payload: AppendEntriesResponse {
                        term: servers[to].currentTerm,
                        success: True,
                        matchIndex: request.prevLogIndex + size(request.entries),
                      },
                    });
                  } else {
                    // leave request in network for further processing
                  }
                } else {
                  remove(network, message);
                  sendMessage(rejectReply);
                }
              },
              Candidate => {
                servers[to].state = Follower {
                  vote: Granted { to: to },
                };
                // leave request in network for further processing
              },
              Leader => {
                assert False;
              },
            }
          }
        }
      }, // AppendEntriesRequest

      AppendEntriesResponse as reply => {
        if reply.term == servers[to].currentTerm {
          match servers[to].state {
            Follower => {
              // Must have restarted to get back into Follower state after
              // AppendEntries. Just ignore it.
            },
            Candidate => {
              // Must have restarted to get back into Candidate state after
              // AppendEntries. Just ignore it.
            },
            Leader as lstate => {
              if reply.success {
                lstate.peers[from].nextIndex = reply.matchIndex + 1;
                lstate.peers[from].matchIndex = reply.matchIndex;
                servers[to].state = lstate;
              } else {
                if lstate.peers[from].nextIndex > 1 {
                  lstate.peers[from].nextIndex -= 1;
                }
              }
            },
          }
        } else {
          if reply.term > servers[to].currentTerm {
            servers[to].currentTerm = reply.term;
            servers[to].state = Follower {};
          } else {
            // stale term: ignore
          }
        }
        remove(network, message);
      }, // AppendEntriesResponse
    }
  }
}

external dropMessage for message in network {
  remove(network, message);
}

external duplicateMessage for message in network {
  if !full(network) {
    var messageCopy : Message = message;
    messageCopy.deliverAt = later(urandomRange(10000, 20000));
    push(network, messageCopy);
  }
}

invariant VotesConsistent {
  for serverId, server in servers {
    match server.state {
      Follower => {},
      Candidate as cstate => {
        for peerId, peer in cstate.peers {
          if peerId == serverId {
            assert peer.voteGranted;
          }
          if peer.voteGranted {
            assert peer.voteResponded;
            if servers[peerId].currentTerm == server.currentTerm {
              match servers[peerId].state {
                Follower as fstate => { 
                  match fstate.vote {
                    Available => { assert False; },
                    Granted as g => { assert g.to == serverId; },
                  }
                },
                Candidate => {
                  assert peerId == serverId; 
                },
                Leader => { assert False; },
              }
            }
          }
        }
      },
      Leader => {},
    }
  }
}

invariant LeaderPeersConsistent {
  for serverId, server in servers {
    match server.state {
      Follower => {},
      Candidate => {},
      Leader as lstate => {
        for peerId, peer in lstate.peers {
          assert 1 <= peer.nextIndex;
          assert peer.nextIndex <= size(server.log) + 1;
          assert 0 <= peer.matchIndex;
          assert peer.matchIndex <= size(server.log);
          if servers[peerId].currentTerm == server.currentTerm {
            assert peer.matchIndex <= size(servers[peerId].log);
          }
          if peerId == serverId {
            assert peer.nextIndex == size(server.log) + 1;
            assert peer.matchIndex == size(server.log);
          }
        }
      },
    }
  }
}

invariant CommitIndexConsistent {
  for server in servers {
    assert server.commitIndex <= size(server.log);
  }
}

invariant LogTermsMonotonic {
  for server in servers {
    var term : MaybeTerm = 0;
    for entry in server.log {
      assert entry.term >= term;
      term = entry.term;
    }
  }
}

invariant LogTermLeqCurrentTerm {
  for server in servers {
    assert lastTerm(server.log) <= server.currentTerm;
  }
}

invariant LeaderWonElection {
  for serverId, server in servers {
    match server.state {
      Follower => {},
      Candidate => {},
      Leader => {
        assert (electionHistory[server.currentTerm] ==
          Winner { won: serverId });
      }
    }
  }
}

invariant LogMatching {
  for server1 in servers {
    for server2 in servers {
      var index : MaybeIndex = size(server1.log);
      if size(server2.log) < index {
        index = size(server2.log);
      }
      while index > 0 {
        if server1.log[index].term == server2.log[index].term {
          while index > 0 {
            assert server1.log[index] == server2.log[index];
            index -= 1;
          }
          break;
        } else {
          index -= 1;
        }
      }
    }
  }
}

invariant LeaderCompleteness {
  for server in servers {
    match server.state {
      Follower => {},
      Candidate => {},
      Leader => {
        for index, centry in committedEntries {
          if centry.termCommitted <= server.currentTerm {
            assert server.log[index] == centry.entry;
          }
        }
      }
    }
  }
}

invariant CommittedEntriesAgreement {
  for server in servers {
    for index, centry in committedEntries {
      if index > server.commitIndex {
        break;
      }
      assert server.log[index] == centry.entry;
    }
  }
}
